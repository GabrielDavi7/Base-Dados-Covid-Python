# -*- coding: utf-8 -*-
"""Cópia_de_trabalho_final (2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Irt56fRHGlgX5p0kUjvSp07wsYOt0w9i
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
from matplotlib import pyplot as plt
import numpy as np
import seaborn as sns
from sklearn.metrics import r2_score,mean_absolute_error,mean_squared_error
from statsmodels.stats.diagnostic import normal_ad
from sklearn.preprocessing import MinMaxScaler
from sklearn import linear_model
from sklearn.model_selection import train_test_split,cross_val_score
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
# %matplotlib inline

from google.colab import drive
drive.mount('/content/drive')

tabela = pd.read_csv('/content/drive/MyDrive/Covid Data.csv')

tabela['CLASIFFICATION_FINAL'] = tabela['CLASIFFICATION_FINAL'].replace({1: 1, 2: 1, 3: 1, 7: 0, 5: 0, 6: 0, 4: 0})
colunas  = ['DIABETES','SEX','PATIENT_TYPE','PNEUMONIA','ASTHMA','INMSUPR','HIPERTENSION','OTHER_DISEASE','CARDIOVASCULAR','OBESITY','RENAL_CHRONIC','TOBACCO' ]

for col in colunas :
  tabela[col] = tabela[col].replace({1: 0, 2: 1})

tabela.shape

tabela.head()

tabela.describe()

tabela.info()

"""sex: 1 para feminino e 2 para masculino.


age: idade do paciente.

classification: resultados de testes ambiciosos. Valores de 1 a 3 significam que o paciente foi diagnosticado com covid em diferentes graus. 4 ou superior significa que o paciente não é portador de covid ou que o teste é inconclusivo.

patient type:  tipo de atendimento que o paciente recebeu na unidade. 1 para regresso a casa e 2 para internamento.


pneumonia: se o paciente já tem inflamação dos sacos aéreos ou não.

pregnancy: se a paciente está grávida ou não.

diabetes: se o paciente tem diabetes ou não.

copd: Indica se o paciente tem doença pulmonar obstrutiva crônica ou não.

asthma:  se o paciente tem asma ou não

inmsupr: se o paciente é imunossuprimido ou não.

hypertension: se o paciente tem hipertensão ou não.

cardiovascular: se o paciente tem doença relacionada ao coração ou aos vasos sanguíneos.

renal chronic: se o paciente tem doença renal crônica ou não.

other disease: se o paciente tem outra doença ou não.

obesity: se o paciente é obeso ou não.

tobacco: se o paciente é tabagista.

usmr: Indica se o paciente tratou unidades médicas de primeiro, segundo ou terceiro nível.

medical unit: tipo de instituição do Sistema Único de Saúde que prestou o atendimento.

intubed: se o paciente estava conectado ao ventilador.

icu:  Indica se o paciente foi internado em uma Unidade de Terapia Intensiva.

date died: Se o paciente faleceu indicar a data do falecimento, caso contrário 9999-99-99.
"""

tabela.hist(bins=30, figsize=(80,50),color='green');plt.show()

plt.figure(figsize = (20,10))
sns.barplot(x = 'SEX', y = 'CLASIFFICATION_FINAL', data=tabela)
plt.show()

Intubed_corte='97'
lixo = tabela[tabela['INTUBED'] == Intubed_corte]
tabela_limpa = tabela[tabela['INTUBED'] != Intubed_corte]
tabela_limpa

Intubed_corte=97
Intubed_corte2=99
lixo = tabela[tabela['INTUBED'] == Intubed_corte]
tabela_limpa = tabela[tabela['INTUBED'] != Intubed_corte]

lixo2 = tabela_limpa[tabela_limpa['INTUBED'] == Intubed_corte2]
tabela_limpa2 = tabela_limpa[tabela_limpa['INTUBED'] != Intubed_corte2]
tabela_limpa2

data_corte='9999-99-99'
vivo = tabela_limpa2[tabela_limpa2['DATE_DIED'] == data_corte]
morto = tabela_limpa2[tabela_limpa2['DATE_DIED'] != data_corte]

vivo

morto

morto.hist(bins=30, figsize=(80,50),color='green');plt.show()

vivo.hist(bins=30, figsize=(80,50),color='green');plt.show()

"""##parte 2

"""

#colunas selecionadas para normalização

cols = ['DIABETES','COPD','ASTHMA','INMSUPR','HIPERTENSION','OTHER_DISEASE','OBESITY','RENAL_CHRONIC','TOBACCO']
scaler = MinMaxScaler(feature_range=(-1, 1))

# Ajustando a tabela
tabela[cols] = scaler.fit_transform(tabela[cols])

tabela[tabela.isnull().any(axis=1)]

tabela = tabela.dropna() #sem linhas nulas

correlacao = tabela[['DIABETES','COPD','ASTHMA','INMSUPR','HIPERTENSION','OTHER_DISEASE','OBESITY','RENAL_CHRONIC','TOBACCO','INTUBED']]
plt.figure(figsize=(10,8))


correlacao.describe()
sns.heatmap(correlacao.corr(), annot = True)

correlacao2 = vivo
plt.figure(figsize=(50,30))


correlacao2.describe()
sns.heatmap(correlacao.corr(), annot = True)

correlacao1 = morto
plt.figure(figsize=(50,30))


correlacao1.describe()
sns.heatmap(correlacao.corr(), annot = True)

x = vivo[['INTUBED']].head(67982)
y = morto[['INTUBED']]
print(x.shape, y.shape)

from sklearn.neighbors import KNeighborsClassifier
#knn com 5 vizinhos
classifier = KNeighborsClassifier(n_neighbors = 5)
#treina o modelo
classifier.fit(x, y)

##igualando quantidade de dados variaveis

len_x = len(x)
len_y = len(y)

if len_x > len_y:
    # Amostrar aleatoriamente os dados de x para igualar o tamanho de y
    x = x.sample(n=len_y, random_state=42)
elif len_y > len_x:
    # Amostrar aleatoriamente os dados de y para igualar o tamanho de x
    y = y.sample(n=len_x, random_state=42)

from sklearn.neighbors import KNeighborsClassifier
#knn com 5 vizinhos
classifier = KNeighborsClassifier(n_neighbors = 5)
#treina o modelo
classifier.fit(x, y)

#predição dos valores
y_pred = classifier.predict(x)
print(y_pred[:4])

#avaliar o desempenho: acurária = total de acertos/total
acuracia =  classifier.score(x, y)
print(acuracia)

##vamos dividir os dados em conjunto de treinamento e teste
from sklearn.model_selection import train_test_split
#75% treinamento 25% para teste
x_treinamento, x_teste, y_treinamento, y_teste = train_test_split(x, y, test_size=0.50, random_state=10)

#modelo 1
classifier1 = KNeighborsClassifier(n_neighbors = 5)
#treina o modelo
classifier1.fit(x_treinamento, y_treinamento)
#predição dos valores
y_pred = classifier1.predict(x_teste)
#avaliar o desempenho: acurária = total de acertos/total
pontos =  classifier1.score(x_teste, y_teste)
print(pontos)

#knn com dois vizinhos
#modelo 2
classifier2 = KNeighborsClassifier(n_neighbors = 3)
#treina o modelo
classifier2.fit(x_treinamento, y_treinamento)
#predição dos valores
y_pred = classifier2.predict(x_teste)
#avaliar o desempenho: acurária = total de acertos/total
pontos =  classifier2.score(x_teste, y_teste)
print(pontos)

from sklearn.metrics import r2_score
r2_score(y_teste, y_pred)
#os pressupostos não foram avaliados

from sklearn.metrics import confusion_matrix

# supondo que você tenha previsto valores e os valores reais, armazenados em duas variáveis separadas

# criar matriz de confusão
#tabela.price_range.shape.shape
conf_matrix = confusion_matrix(x_teste,y_pred)

import seaborn as sns
sns.heatmap(conf_matrix, annot=True, cmap='Blues')
plt.title('Matriz de Confusão')
plt.xlabel('Previsão')
plt.ylabel('Real')
plt.show()

from sklearn.metrics import accuracy_score

accuracy = accuracy_score(y_teste,y_pred)
print(accuracy)

import matplotlib.pyplot as plt
plt.matshow(conf_matrix, cmap=plt.cm.Blues)
plt.colorbar()

from sklearn.metrics import classification_report

report = classification_report(x_teste,y_pred)

from sklearn.metrics import precision_score
from sklearn.metrics import precision_score, recall_score, f1_score, accuracy_score
from sklearn.metrics import confusion_matrix
precision = precision_score(x_teste,y_pred, average='macro')

f1 = f1_score(x_teste, y_pred,average='macro')
recall = recall_score(x_teste, y_pred, average='macro')

print("Matriz de Confusão:\n", conf_matrix)
print("\nPrecisão:", precision)
print("\nAcurácia:", accuracy)
print("\nF1-score:", f1)
print("\nRecall:", recall)
print("\n\n")
print("Report:", report)

from sklearn.preprocessing import StandardScaler
from sklearn.feature_selection import SelectKBest

scaler = StandardScaler()
x_scaled = scaler.fit_transform(x)

selector = SelectKBest(k='all')  # Vamos selecionar os 5 melhores atributos
x_selected = selector.fit_transform(x_scaled, y)

model = LogisticRegression()
model.fit(x_selected, y)

scores = cross_val_score(model, x_selected, y, cv=5)  # cv=5 indica 5 folds na validação cruzada

y_pred2 = model.predict(x_selected)

# Impressão do resultado
print("Resultado da predição:")
print(y_pred)

print("\nResultados da validação cruzada:");
print(scores);
print("\nAcurácia média: ", scores.mean());

"""PARTE 3

"""

vivo['ICU']

"""# ***Etapa 3***"""

correlacao = tabela[['DIABETES','COPD','ASTHMA','INMSUPR','HIPERTENSION','OTHER_DISEASE','OBESITY','RENAL_CHRONIC','TOBACCO','INTUBED']]
plt.figure(figsize=(10,8))


correlacao.describe()
sns.heatmap(correlacao.corr(), annot = True)

from sklearn.feature_selection import SequentialFeatureSelector


# Separa as características e o rótulo
x = tabela[['DIABETES','COPD','ASTHMA','INMSUPR','HIPERTENSION','OTHER_DISEASE','OBESITY','RENAL_CHRONIC','TOBACCO','INTUBED']]
y = tabela[['INTUBED']]

nomes_colunas = ['DIABETES','COPD','ASTHMA','INMSUPR','HIPERTENSION','OTHER_DISEASE','OBESITY','RENAL_CHRONIC','TOBACCO','INTUBED']


# Divide o conjunto de dados em treino e teste
x_treinamento, x_test, y_treinamento, y_test = train_test_split(x, y, test_size=0.2, random_state=42, stratify=y)

# Cria um objeto KNN com k=3
knn = KNeighborsClassifier(n_neighbors=7)

# Cria uma lista para armazenar as acurácias obtidas para cada valor de k
scores = []

# Loop para ajustar o modelo e calcular a acurácia para cada valor de k
for k in range(1, 20):


    # Cria um objeto Sequential Feature Selector para selecionar as k melhores características
    sfs = SequentialFeatureSelector(knn, n_features_to_select=k)

    # Aplica o Sequential Feature Selector ao conjunto de dados de treino
    X_train_sfs = sfs.fit_transform(x_treinamento, y_treinamento)

    # Aplica o Sequential Feature Selector ao conjunto de dados de teste
    X_test_sfs = sfs.transform(x_test)

    # Treina o modelo KNN com as características selecionadas
    knn.fit(X_train_sfs, y_treinamento)

    # Obtém os índices das características selecionadas
    selected_features_idx = sfs.get_support(indices=True)


    # Obtém os nomes das características selecionadas
    selected_features_names = [nomes_colunas[i] for i in selected_features_idx]

    # Calcula a acurácia do modelo no conjunto de teste
    score = knn.score(X_test_sfs, y_test)

   # Imprime as características selecionadas
    selected_features = [nomes_colunas[i] for i in selected_features_idx]
    print("Características selecionadas com as {} melhores características:".format(k))
    print(selected_features)
    print("Acurácia com as características selecionadas: {:.2f}%".format(score*100))

# Imprime as acurácias obtidas para cada valor de k
for k, score in enumerate(scores, start=1):
    print("Acurácia com as {} melhores características: {:.2f}%".format(k, score*100))

"""FILTER

"""

from sklearn.feature_selection import SequentialFeatureSelector
from sklearn.metrics import accuracy_score
from sklearn.feature_selection import SelectKBest, chi2
from sklearn.preprocessing import MinMaxScaler

# Separa as características e o rótulo
X = x = tabela[['DIABETES','COPD','ASTHMA','INMSUPR','HIPERTENSION','OTHER_DISEASE','OBESITY','RENAL_CHRONIC','TOBACCO','INTUBED']]

y = tabela[['INTUBED']]

nomes_colunas = ['DIABETES','COPD','ASTHMA','INMSUPR','HIPERTENSION','OTHER_DISEASE','OBESITY','RENAL_CHRONIC','TOBACCO','INTUBED']

scaler = MinMaxScaler()
x = scaler.fit_transform(X)

# Divide o conjunto de dados em treino e teste
x_treinamento, x_test, y_treinamento, y_test = train_test_split(x, y, test_size=0.2, random_state=42,stratify=y)

best_accuracy = 0
best_k = 0

for k in range(1, 20):
    # Realiza a seleção de características usando SelectKBest e chi2
    selector = SelectKBest(chi2, k=k)
    X_train_new = selector.fit_transform(X_train, y_train)
    X_test_new = selector.transform(X_test)

    # Cria um modelo KNN com k=7 e treina com as características selecionadas
    knn = KNeighborsClassifier(n_neighbors=7)
    knn.fit(X_train_new, y_train)

    # Faz as previsões no conjunto de teste e calcula a acurácia
    y_pred = knn.predict(X_test_new)
    accuracy = accuracy_score(y_test, y_pred)

    if accuracy > best_accuracy:
        best_accuracy = accuracy
        best_k = k

    # Obtém os índices das características selecionadas
    selected_features_idx = selector.get_support(indices=True)


    # Obtém os nomes das características selecionadas
    selected_features_names = [nomes_colunas[i] for i in selected_features_idx]

    # Obtém os valores de chi2 de todas as características
    chi2_scores = selector.scores_

    # Obtém os valores de chi2 das características selecionadas
    selected_chi2_scores = chi2_scores[selected_features_idx]

    # Imprime as características selecionadas e seus valores de chi2
    print("Características selecionadas para k = {}: {}".format(k, selected_features_names))
    print("Acurácia com as características selecionadas: {:.2f}%".format(accuracy*100))



# Imprime a acurácia e o melhor valor de k encontrado
print("Melhor valor de k: {}".format(best_k))
print("Acurácia com as características selecionadas: {:.2f}%".format(best_accuracy*100))